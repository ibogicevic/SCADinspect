/* original grammar file: https://github.com/openscad/openscad/blob/master/src/parser.y */

package scadinspect.parser.generated;

import scadinspect.parser.ast.*;

/* Expect 2 shift/reduce conflict for ifelse_statement - "dangling else problem", handled in CUP config */

/* error reporting is overwittern in CustomErrorOpenScadParser */

terminal TOK_ERROR;

terminal TOK_MODULE;
terminal TOK_FUNCTION;
terminal TOK_IF;
terminal TOK_ELSE;
terminal TOK_FOR;
terminal TOK_LET;
terminal TOK_ASSERT;
terminal TOK_ECHO;
terminal TOK_EACH;

terminal String TOK_ID;
terminal String TOK_STRING;
terminal String TOK_USE;
terminal Double TOK_NUMBER;

terminal TOK_TRUE;
terminal TOK_FALSE;
terminal TOK_UNDEF;

terminal LE, GE, EQ, NE, AND, OR;

terminal SEMICOLON, DOT, COLON, COMMA;
terminal BRACKET_CURLY_OPEN, BRACKET_CURLY_CLOSE;
terminal BRACKET_ROUND_OPEN, BRACKET_ROUND_CLOSE;
terminal BRACKET_SQUARE_OPEN, BRACKET_SQUARE_CLOSE;
terminal BRACKET_ANGLE_OPEN, BRACKET_ANGLE_CLOSE;
terminal EQUAL;
terminal EXCLAMATION_MARK, QUESTION_MARK, HASH, PERCENT, ASTERISK, SLASH, PLUS, MINUS;

terminal LET, LOW_PRIO_LEFT, LOW_PRIO_RIGHT, HIGH_PRIO_LEFT, HIGH_PRIO_RIGHT;


non terminal InputNode input;
non terminal StatementNode statement;
non terminal InnerInputNode inner_input;
non terminal AssignmentNode assignment;
non terminal ModuleInstantiationNode module_instantiation;
non terminal IfElseStatementNode ifelse_statement;
non terminal IfStatementNode if_statement;
non terminal ChildStatementsNode child_statements;
non terminal ChildStatementNode child_statement;
non terminal ModuleIdNode module_id;
non terminal SingleModuleInstantiationNode single_module_instantiation;
non terminal ExprNode expr;
non terminal ExprOrEmptyNode expr_or_empty;
non terminal ListComprehensionElementsNode list_comprehension_elements;
non terminal ListComprehensionElementsPNode list_comprehension_elements_p;
non terminal ListComprehensionElementsOrExprNode list_comprehension_elements_or_expr;
non terminal OptionalCommasNode optional_commas;
non terminal VectorExprNode vector_expr;
non terminal ArgumentsDeclNode arguments_decl;
non terminal ArgumentDeclNode argument_decl;
non terminal ArgumentsCallNode arguments_call;
non terminal ArgumentCallNode argument_call;

precedence right LET;
precedence right LOW_PRIO_RIGHT;
precedence left LOW_PRIO_LEFT;

precedence right QUESTION_MARK, COLON;

precedence left OR;
precedence left AND;

precedence left BRACKET_ANGLE_OPEN, LE, GE, BRACKET_ANGLE_CLOSE;
precedence left EQ, NE;

precedence left EXCLAMATION_MARK, PLUS, MINUS;
precedence left ASTERISK, SLASH, PERCENT;
precedence left BRACKET_SQUARE_OPEN, BRACKET_SQUARE_CLOSE;
precedence left DOT;

precedence right HIGH_PRIO_RIGHT;
precedence left HIGH_PRIO_LEFT;


start with input;

input ::=
          /* empty */
        {:  RESULT = InputNode.createEmpty(); :}
        | TOK_USE:u input:i
        {:  RESULT = InputNode.createUse(u, i); :}
        | statement:s input:i
        {:  RESULT = InputNode.createStatement(s, i); :}
        ;

statement ::=
          SEMICOLON
        {: RESULT = StatementNode.createSemicolon(); :}
        | BRACKET_CURLY_OPEN inner_input:i BRACKET_CURLY_CLOSE
        {:  RESULT = StatementNode.createInnerInput(i); :}
        | module_instantiation:m
        {: RESULT = StatementNode.createModuleInstantiation(m); :}
        | assignment:a
        {: RESULT = StatementNode.createAssignment(a); :}
        | TOK_MODULE TOK_ID:id
          BRACKET_ROUND_OPEN arguments_decl:ad optional_commas:oc BRACKET_ROUND_CLOSE
          statement:s
        {: RESULT = StatementNode.createModuleDefinition(id, ad, oc, s); :}
        | TOK_FUNCTION TOK_ID:id
          BRACKET_ROUND_OPEN arguments_decl:ad optional_commas:oc  BRACKET_ROUND_CLOSE
          EQUAL expr:e SEMICOLON
        {: RESULT = StatementNode.createFunctionDefinition(id, ad, oc, e); :}
        ;

inner_input ::=
          /* empty */
        {: RESULT = InnerInputNode.createEmpty(); :}
        | statement:s inner_input:i
        {: RESULT = InnerInputNode.createStatement(s, i); :}
        ;

assignment ::=
          TOK_ID:id EQUAL expr:e SEMICOLON
        {: RESULT = AssignmentNode.createAssignment(id, e); :}
        ;


module_instantiation ::=
          EXCLAMATION_MARK module_instantiation:m
        {: RESULT = ModuleInstantiationNode.createWithExclamationMark(m); :}
        | HASH module_instantiation:m
        {: RESULT = ModuleInstantiationNode.createWithHash(m); :}
        | PERCENT module_instantiation:m
        {: RESULT = ModuleInstantiationNode.createWithPercent(m); :}
        | ASTERISK module_instantiation:m
        {: RESULT = ModuleInstantiationNode.createWithAsterisk(m); :}
        | single_module_instantiation:sm
          child_statement:cs
        {: RESULT = ModuleInstantiationNode.createSingle(sm, cs); :}
        | ifelse_statement:ies
        {: RESULT = ModuleInstantiationNode.createIfElse(ies); :}
        ;

ifelse_statement ::=
          if_statement:is
        {: RESULT = IfElseStatementNode.createIf(is); :}
        | if_statement:is TOK_ELSE
          child_statement:cs
        {: RESULT = IfElseStatementNode.createIfElse(is, cs); :}
        ;

if_statement ::=
          TOK_IF BRACKET_ROUND_OPEN expr:e BRACKET_ROUND_CLOSE
          child_statement:cs
        {: RESULT = IfStatementNode.createIf(e, cs); :}
        ;

child_statements ::=
          /* empty */
        {: RESULT = ChildStatementsNode.createEmpty(); :}
        | child_statements:css child_statement:cs
        {: RESULT = ChildStatementsNode.createChildStatement(css, cs); :}
        | child_statements:css assignment:a
        {: RESULT = ChildStatementsNode.createAssignment(css, a); :}
        ;

child_statement ::=
          SEMICOLON
        {: RESULT = ChildStatementNode.createSemicolon(); :}
        | BRACKET_CURLY_OPEN child_statements:css BRACKET_CURLY_CLOSE
        {: RESULT = ChildStatementNode.createChildStatements(css); :}
        | module_instantiation:m
        {: RESULT = ChildStatementNode.createModuleInstantiation(m); :}
        ;

// "for", "let" and "each" are valid module identifiers
module_id ::=
          TOK_ID:id
        {: /*System.out.println("Module ID: " +  i); */
            RESULT = ModuleIdNode.createId(id); :}
        | TOK_FOR
        {: RESULT = ModuleIdNode.createFor(); :}
        | TOK_LET
        {: RESULT = ModuleIdNode.createLet(); :}
        | TOK_ASSERT
        {: RESULT = ModuleIdNode.createAssert(); :}
        | TOK_ECHO
        {: RESULT = ModuleIdNode.createEcho(); :}
        | TOK_EACH
        {: RESULT = ModuleIdNode.createEach(); :}
        ;

single_module_instantiation ::=
          module_id:mid BRACKET_ROUND_OPEN arguments_call:ac BRACKET_ROUND_CLOSE
        {: RESULT = SingleModuleInstantiationNode.createSingle(mid, ac); :}
        ;

expr ::=
          TOK_TRUE
        {: RESULT = ExprNode.createTrue(); :}
        | TOK_FALSE
        {: RESULT = ExprNode.createFalse(); :}
        | TOK_UNDEF
        {: RESULT = ExprNode.createUndef(); :}
        | TOK_ID:id
        {: RESULT = ExprNode.createId(id); :}
        | expr:e DOT TOK_ID:id
        {: RESULT = ExprNode.createExprDotId(e, id); :}
        | TOK_STRING:s
        {: /* System.out.println("String: " + s); */
          RESULT = ExprNode.createString(s); :}
        | TOK_NUMBER:n
        {: /* System.out.println("Number value: " + (Double) n); */
           RESULT = ExprNode.createNumber(n); :}
        | BRACKET_SQUARE_OPEN expr:e1 COLON expr:e2 BRACKET_SQUARE_CLOSE
        {: RESULT = ExprNode.createExprColonExpr(e1, e2); :}
        | BRACKET_SQUARE_OPEN expr:e1 COLON expr:e2 COLON expr:e3 BRACKET_SQUARE_CLOSE
        {: RESULT = ExprNode.createExprColonExprColonExpr(e1, e2, e3); :}
        | BRACKET_SQUARE_OPEN optional_commas:oc BRACKET_SQUARE_CLOSE
        {: RESULT = ExprNode.createOptionalCommas(oc); :}
        | BRACKET_SQUARE_OPEN vector_expr:ve optional_commas:oc BRACKET_SQUARE_CLOSE
        {: RESULT = ExprNode.createVector(ve, oc); :}
        | expr:e1 ASTERISK expr:e2
        {: RESULT = ExprNode.createMultiplication(e1, e2); :}
        | expr:e1 SLASH expr:e2
        {: RESULT = ExprNode.createDivision(e1, e2); :}
        | expr:e1 PERCENT expr:e2
        {: RESULT = ExprNode.createModulo(e1, e2); :}
        | expr:e1 PLUS expr:e2
        {: RESULT = ExprNode.createAddition(e1, e2); :}
        | expr:e1 MINUS expr:e2
        {: RESULT = ExprNode.createSubtraction(e1, e2); :}
        | expr:e1 BRACKET_ANGLE_OPEN expr:e2
        {: RESULT = ExprNode.createLess(e1, e2); :}
        | expr:e1 LE expr:e2
        {: RESULT = ExprNode.createLessEqual(e1, e2); :}
        | expr:e1 EQ expr:e2
        {: RESULT = ExprNode.createEqual(e1, e2); :}
        | expr:e1 NE expr:e2
        {: RESULT = ExprNode.createNotEqual(e1, e2); :}
        | expr:e1 GE expr:e2
        {: RESULT = ExprNode.createGreaterEqual(e1, e2); :}
        | expr:e1 BRACKET_ANGLE_CLOSE expr:e2
        {: RESULT = ExprNode.createGreater(e1, e2); :}
        | expr:e1 AND expr:e2
        {: RESULT = ExprNode.createAnd(e1, e2); :}
        | expr:e1 OR expr:e2
        {: RESULT = ExprNode.createOr(e1, e2); :}
        | PLUS expr:e
        {: RESULT = ExprNode.createUnaryPlus(e); :}
        | MINUS expr:e
        {: RESULT = ExprNode.createUnaryMinus(e); :}
        | EXCLAMATION_MARK expr:e
        {: RESULT = ExprNode.createNot(e); :}
        | BRACKET_ROUND_OPEN expr:e BRACKET_ROUND_CLOSE
        {: RESULT = ExprNode.createParentheses(e); :}
        | expr:e1 QUESTION_MARK expr:e2 COLON expr:e3
        {: RESULT = ExprNode.createTernary(e1,e2, e3); :}
        | expr:e1 BRACKET_SQUARE_OPEN expr:e2 BRACKET_SQUARE_CLOSE
        {: RESULT = ExprNode.createArrayAccess(e1, e2); :}
        | TOK_ID:id BRACKET_ROUND_OPEN arguments_call:ac BRACKET_ROUND_CLOSE
        {: RESULT = ExprNode.createFunctionCall(id, ac); :}
        | TOK_LET BRACKET_ROUND_OPEN arguments_call:ac BRACKET_ROUND_CLOSE expr:e
        {: RESULT = ExprNode.createLet(ac, e); :}
        %prec LET
        | TOK_ASSERT BRACKET_ROUND_OPEN arguments_call:ac BRACKET_ROUND_CLOSE expr_or_empty:e
        {: RESULT = ExprNode.createAssert(ac, e); :}
        %prec LOW_PRIO_LEFT
        | TOK_ECHO BRACKET_ROUND_OPEN arguments_call:ac BRACKET_ROUND_CLOSE expr_or_empty:e
        {: RESULT = ExprNode.createEcho(ac, e); :}
        %prec LOW_PRIO_LEFT
        ;

expr_or_empty ::=
          /* empty */
        {: RESULT = ExprOrEmptyNode.createEmpty(); :}
        %prec LOW_PRIO_LEFT
        | expr:e
        {: RESULT = ExprOrEmptyNode.createExpr(e); :}
        %prec HIGH_PRIO_LEFT
        ;

list_comprehension_elements ::=
          /* The last set element may not be a "let" (as that would instead
             be parsed as an expression) */
          TOK_LET BRACKET_ROUND_OPEN arguments_call:ac BRACKET_ROUND_CLOSE list_comprehension_elements_p:lcesp
        {: RESULT = ListComprehensionElementsNode.createLet(ac, lcesp); :}
        | TOK_EACH list_comprehension_elements_or_expr:lcese
        {: RESULT = ListComprehensionElementsNode.createEach(lcese); :}
        | TOK_FOR BRACKET_ROUND_OPEN arguments_call:ac BRACKET_ROUND_CLOSE list_comprehension_elements_or_expr:lcese
        {: RESULT = ListComprehensionElementsNode.createFor(ac, lcese); :}
        | TOK_FOR BRACKET_ROUND_OPEN arguments_call:ac1 SEMICOLON expr:e SEMICOLON arguments_call:ac2 BRACKET_ROUND_CLOSE list_comprehension_elements_or_expr:lcese
        {: RESULT = ListComprehensionElementsNode.createForWithSemicolons(ac1, e, ac2, lcese); :}
        | TOK_IF BRACKET_ROUND_OPEN expr:e BRACKET_ROUND_CLOSE list_comprehension_elements_or_expr:lcese
        {: RESULT = ListComprehensionElementsNode.createIf(e, lcese); :}
        | TOK_IF BRACKET_ROUND_OPEN expr:e BRACKET_ROUND_CLOSE list_comprehension_elements_or_expr:lcese1 TOK_ELSE list_comprehension_elements_or_expr:lcese2
        {: RESULT = ListComprehensionElementsNode.createIfElse(e, lcese1, lcese2); :}
        ;

/* list_comprehension_elements with optional parenthesis */
list_comprehension_elements_p ::=
          list_comprehension_elements:lces
        {: RESULT = ListComprehensionElementsPNode.createList(lces); :}
        | BRACKET_ROUND_OPEN list_comprehension_elements:lces BRACKET_ROUND_CLOSE
        {: RESULT = ListComprehensionElementsPNode.createParentheses(lces); :}
        ;

list_comprehension_elements_or_expr ::=
          list_comprehension_elements_p:lcesp
        {: RESULT = ListComprehensionElementsOrExprNode.createListP(lcesp); :}
        | expr:e
        {: RESULT = ListComprehensionElementsOrExprNode.createExpr(e); :}
        ;

optional_commas ::=
          COMMA optional_commas:oc
        {: RESULT = OptionalCommasNode.createComma(oc); :}
        | /* empty */
        {: RESULT = OptionalCommasNode.createEmpty(); :}
        ;

vector_expr ::=
          expr:e
        {: RESULT = VectorExprNode.createExpr(e); :}
        |  list_comprehension_elements:lces
        {: RESULT = VectorExprNode.createListComprehensionElements(lces); :}
        | vector_expr:ve COMMA optional_commas:oc list_comprehension_elements_or_expr:lcese
        {: RESULT = VectorExprNode.createWithComma(ve, oc, lcese); :}
        ;

arguments_decl ::=
          /* empty */
        {: RESULT = ArgumentsDeclNode.createEmpty(); :}
        | argument_decl:ad
        {: RESULT = ArgumentsDeclNode.createArgumentDecl(ad); :}
        | arguments_decl:asd COMMA optional_commas:oc argument_decl:ad
        {: RESULT = ArgumentsDeclNode.createWithComma(asd, oc, ad); :}
        ;

argument_decl ::=
          TOK_ID:id
        {: RESULT = ArgumentDeclNode.createId(id); :}
        | TOK_ID:id EQUAL expr:e
        {: RESULT = ArgumentDeclNode.createIdExpr(id, e); :}
        ;

arguments_call ::=
          /* empty */
        {: RESULT = ArgumentsCallNode.createEmpty(); :}
        | argument_call:ac
        {: RESULT = ArgumentsCallNode.createArgumentCall(ac); :}
        | arguments_call:asc COMMA optional_commas:oc argument_call:ac
        {: RESULT = ArgumentsCallNode.createWithComma(asc, oc, ac); :}
        ;

argument_call ::=
          expr:e
        {: RESULT = ArgumentCallNode.createExpr(e); :}
        | TOK_ID:id EQUAL expr:e
        {: RESULT = ArgumentCallNode.createIdExpr(id, e); :}
        ;

